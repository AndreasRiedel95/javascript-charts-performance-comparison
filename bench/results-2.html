<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Benchmark results FPS visualization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0px 0px 0px 0px;
      }
    </style>
  </head>
  <body>
    <script src="lcjs.iife.js"></script>
    <script>
      const {
        lightningChart,
        AxisTickStrategies,
        SolidFill,
        ColorHSV,
        SolidLine,
        emptyFill,
        emptyLine,
        AutoCursorModes,
        UIOrigins,
        LinearGradientFill,
        HighlightModes,
      } = lcjs;

      let src = 'pc'
      try {
        src = document.URL.match(/\?src=(.*)/)[1];
      } catch (e) {
        console.error(`url parsing error: ${e.message}`)
      }

      const visualizeBenchmarkResults = (benchmarks) => {
        console.log(benchmarks);

        const formatNum = (num) => {
          if (num > 1000 * 1000) return (num / (1000 * 1000)).toFixed(0) + ' M';
          if (num > 1000) return (num / 1000).toFixed(0) + ' k';
          return num.toFixed(0);
        };
        const format = (builder, category, value, group) => {
          const iCategory = categories.indexOf(category);
          const fps = group.values[iCategory];
          return builder
            .addRow(group.name, '')
            .addRow(category.name, '')
            .addRow('FPS (avg): ', '', fps ? fps.toFixed(1) : 'Fail')
            .addRow(
              'Total data per second: ',
              '',
              formatNum(category.totalDataPointsPerSecond)
            )
            .addRow(
              'Total data visible: ',
              '',
              formatNum(category.totalVisibleDataPoints)
            );
        };

        const categories = [
          {
            name: '1 ch, 1 kHz, 1 s',
            getBenchmarks: (benchmarks) =>
              benchmarks.filter(
                (item) =>
                  item.config.channelsCount === 1 &&
                  item.config.channelDataPointsPerSecond === 1000 &&
                  item.config.timeDomainInterval === 1000
              ),
            format,
            totalDataPointsPerSecond: 1 * 1000,
            totalVisibleDataPoints: 1 * 1000 * 1,
          },
          {
            name: '1 ch, 10 kHz, 1 s',
            getBenchmarks: (benchmarks) =>
              benchmarks.filter(
                (item) =>
                  item.config.channelsCount === 1 &&
                  item.config.channelDataPointsPerSecond === 10000 &&
                  item.config.timeDomainInterval === 10000
              ),
            format,
            totalDataPointsPerSecond: 1 * 10000,
            totalVisibleDataPoints: 1 * 10000 * 1,
          },
          {
            name: '10 ch, 10 kHz, 1 s',
            getBenchmarks: (benchmarks) =>
              benchmarks.filter(
                (item) =>
                  item.config.channelsCount === 10 &&
                  item.config.channelDataPointsPerSecond === 10000 &&
                  item.config.timeDomainInterval === 10000
              ),
            format,
            totalDataPointsPerSecond: 10 * 10000,
            totalVisibleDataPoints: 10 * 10000 * 1,
          },
          {
            name: '10 ch, 100 kHz, 10 s',
            getBenchmarks: (benchmarks) =>
              benchmarks.filter(
                (item) =>
                  item.config.channelsCount === 10 &&
                  item.config.channelDataPointsPerSecond === 100000 &&
                  item.config.timeDomainInterval === 1000000
              ),
            format,
            totalDataPointsPerSecond: 10 * 100000,
            totalVisibleDataPoints: 10 * 100000 * 10,
          },
          // + LCJS only tests
          {
            name: '20 ch, 100 kHz, 10 s',
            getBenchmarks: (benchmarks) =>
              benchmarks.filter(
                (item) =>
                  item.config.channelsCount === 20 &&
                  item.config.channelDataPointsPerSecond === 100000 &&
                  item.config.timeDomainInterval === 1000000
              ),
            format,
            totalDataPointsPerSecond: 20 * 100000,
            totalVisibleDataPoints: 20 * 100000 * 10,
          },
        ];

        if (src === 'high-end-pc') {
          categories.push({
            name: '10 ch, 500 kHz, 2 s',
            getBenchmarks: (benchmarks) =>
              benchmarks.filter(
                (item) =>
                  item.config.channelsCount === 10 &&
                  item.config.channelDataPointsPerSecond === 500000 &&
                  item.config.timeDomainInterval === 1000000
                                                
              ),
            format,
            totalDataPointsPerSecond: 10 * 500000,
            totalVisibleDataPoints: 10 * 500000 * 2,
          },
          {
            name: '10 ch, 1 MHz, 1 s',
            getBenchmarks: (benchmarks) =>
              benchmarks.filter(
                (item) =>
                  item.config.channelsCount === 10 &&
                  item.config.channelDataPointsPerSecond === 1000000 &&
                  item.config.timeDomainInterval === 1000000
              ),
            format,
            totalDataPointsPerSecond: 10 * 1000000,
            totalVisibleDataPoints: 10 * 1000000 * 1,
          })
        }

        const opts = {
          title: `Performance benchmarks visualization (${src})`,
          titleAxisY: 'FPS (average)',
          categories,
          groups: benchmarks.map((libResult) => ({
            ...libResult,
            name:
              libResult.library.name,
            values: categories.map((category) => {
              const categoryBenchmarks = category.getBenchmarks(
                libResult.benchmarks || []
              );
              try {
                const benchmark = categoryBenchmarks[0];
                const { fps, fail } = benchmark;
                if (fail) return undefined;
                return fps.avg ;
              } catch (e) {
                // console.error(`no value for ${libResult.library.name}, ${category.name} \n(${e.message})`)
                return undefined;
              }
            }),
          })),
          categoryColors: (category, group, iCategory, value) => {
            return ColorHSV(
              ((Math.min(Math.max(value, 20), 60) - 20) / (60 - 20)) * 120
            );
          },
        };
        console.log(opts);
        groupedBarChart(opts);
      };

      const groupedBarChart = (props) => {
        const categoriesCount = props.categories.length;
        const groupsCount = props.groups.length;

        const chart = lightningChart()
          .ChartXY()
          .setPadding({
            left: 80,
            right: 80,
            bottom: 40,
          })
          .setMouseInteractions(false)
          .setAutoCursorMode(AutoCursorModes.onHover)
          .setAutoCursor((cursor) =>
            cursor
              .disposePointMarker()
              .disposeTickMarkerX()
              .disposeTickMarkerY()
              .setGridStrokeXStyle(emptyLine)
              .setGridStrokeYStyle(emptyLine)
          );
        const xAxis = chart
          .getDefaultAxisX()
          .setTickStrategy(AxisTickStrategies.Empty)
          .setMouseInteractions(false);
        const yAxes = new Array(categoriesCount)
          .fill(0)
          .map((_, iCategory) =>
            chart.getDefaultAxisY().setMouseInteractions(false)
          );
        const yAxis = chart.getDefaultAxisY();


        if (props.title) {
          chart.setTitle(props.title);
        } else {
          chart.setTitle('').setTitleFillStyle(emptyFill);
        }
        if (props.titleAxisX) xAxis.setTitle(props.titleAxisX);
        if (props.titleAxisY) yAxis.setTitle(props.titleAxisY);

        const groupsGapX = 1.0;
        const groupItemsWidthX = 1.0;
        const groupItemsGapX = 0.1;
        const marginsLeftRightX = 0.5;
        const xStart = marginsLeftRightX;

        // Each category has own series (same color and y Axis)
        const categorySeries = new Array(categoriesCount)
          .fill(0)
          .map((_, iCategory) => {
            const category = props.categories[iCategory];
            return chart
              .addRectangleSeries({
                yAxis: yAxes[iCategory],
              })
              .setName(category.name)
              .setHighlightMode(HighlightModes.onHover)
              .setCursorResultTableFormatter((builder, series, rectangle) => {
                const group = groupsWithXRange.find(
                  (info) =>
                    rectangle.getDimensionsTwoPoints().x1 >= info.xStart &&
                    rectangle.getDimensionsTwoPoints().x2 <= info.xEnd
                ).group;
                return category.format(
                  builder,
                  category,
                  group.values[iCategory],
                  group
                );
              });
          });

        const groupsWithXRange = [];
        const xEnd = props.groups.reduce((prevXEnd, group, iGroup) => {
          const groupXStart = prevXEnd + (iGroup > 0 ? groupsGapX : 0);
          const xEndGroup = props.categories.reduce(
            (prevXEndGroup, category, iCategory) => {
              const itemXStart =
                prevXEndGroup +
                (iCategory > 0 && iCategory < categoriesCount
                  ? groupItemsGapX
                  : 0);
              const itemXEnd = itemXStart + groupItemsWidthX;
              const itemValue = group.values[iCategory];
              const colorEnd =
                typeof props.categoryColors === 'function'
                  ? props.categoryColors(
                      category,
                      group,
                      iCategory,
                      group.values[iCategory]
                    )
                  : props.categoryColors[iCategory];
              const colorStart = colorEnd.setA(100);
              const series = categorySeries[iCategory];
              const rectangle = series
                .add({
                  x1: itemXStart,
                  x2: itemXEnd,
                  y1: 0,
                  y2: Math.max(0, itemValue),
                })
                .setFillStyle(
                  new LinearGradientFill({
                    angle: 0,
                    stops: [
                      { offset: 0, color: colorStart },
                      { offset: 1, color: colorEnd },
                    ],
                  })
                );

              return itemXEnd;
            },
            groupXStart
          );
          groupsWithXRange.push({
            group,
            xStart: groupXStart,
            xEnd: xEndGroup,
          });

          const groupLabel = xAxis
            .addCustomTick()
            .setValue((groupXStart + xEndGroup) / 2)
            .setTextFormatter(() => group.name)
            .setGridStrokeStyle(emptyLine)
            .setMarker((tickMarker) =>
              tickMarker.setBackground((background) =>
                background.setFillStyle(emptyFill).setStrokeStyle(emptyLine)
              )
            );

          return xEndGroup;
        }, xStart);

        xAxis.setInterval(0, xEnd + marginsLeftRightX, false, true);

        const legend = chart.addLegendBox().add(chart);
      };

      fetch(`benchmarks_${src}.json`)
        .then((r) => r.json())
        .then((benchmarks) => {
          visualizeBenchmarkResults(benchmarks);
        });
    </script>
  </body>
</html>
