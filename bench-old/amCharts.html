<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AmCharts benchmark app</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" type="text/css" href="style.css" media="screen" />

    <style>
      #wait,
      #reference {
        color: black;
      }
    </style>
  </head>
  <body>
    <h2 id="wait">Loading lib....</h2>

    <script src="config.iife.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/core.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/charts.js"></script>
    <script src="https://cdn.amcharts.com/lib/4/themes/animated.js"></script>
    <div id="chart"></div>

    <script>
      let testStopped = false;

      const prepareData = (packedData) => {
        // Map ECG y data into n channels on same X, and Y Axis (offset channels Y coordinate).
        // Source Y data is in range [0, 1].
        const channelsYValues = new Array(BENCHMARK_CONFIG.channelsCount)
          .fill(0)
          .map((_, iChannel) =>
            packedData.map(
              (srcY, iDataPoint) =>
                srcY + (BENCHMARK_CONFIG.channelsCount - (iChannel + 1)) * 1
            )
          );
        return channelsYValues;
      };

      const createChart = (sourceData) => {
        let chart;
        let series;
        let timeAxis;
        am4core.ready(function () {});

        let iDataPoint = 0;
        const timeStart = Date.now();
        const addNDataPoints = (n) => {
          if (n === 0) return;
          // Add new value to each channel data array.
          const channelNewPoints = new Array(BENCHMARK_CONFIG.channelsCount)
            .fill(0)
            .map((_) => []);
          for (let iNewDataPoint = 0; iNewDataPoint < n; iNewDataPoint += 1) {
            const iSourceDataPoint = iDataPoint % sourceData[0].length;
            for (
              let iChannel = 0;
              iChannel < BENCHMARK_CONFIG.channelsCount;
              iChannel += 1
            ) {
              const y = sourceData[iChannel][iSourceDataPoint];
              channelNewPoints[iChannel].push({
                ax: iDataPoint,
                ay: y,
              });
            }
            iDataPoint += 1;
          }
          channelNewPoints.forEach((newPoints, iChannel) => {
            if (series[iChannel].data.length === 0) {
              series[iChannel].data = newPoints;
            } else series[iChannel].addData(newPoints, newPoints.length);
          });
          timeAxis.scrictMinMax = true;
          timeAxis.min = iDataPoint - BENCHMARK_CONFIG.timeDomainInterval;
          timeAxis.max = iDataPoint;
        };

        return {
          renderInitialData: () => {
            return new Promise(async (resolve) => {
              /**
               * NOTE: Ideally chart would be created before `renderInitialData` to remove its effect from delay measurement,
               * but I haven't been able to get 'ready' event working with proper implementation.
               *
               * This way 'ready' works and we get the actual timestamp when chart is ready.
               */

              chart = am4core.create('chart', am4charts.XYChart);
              chart.hiddenState.properties.opacity = 0;
              chart.padding(0, 0, 0, 0);
              chart.zoomOutButton.disabled = true;

              var data = [];
              var visits = 10;
              var i = 0;
              for (i = 0; i <= 30; i++) {
                visits -= Math.round(
                  (Math.random() < 0.5 ? 1 : -1) * Math.random() * 10
                );
                data.push({
                  date: new Date().setSeconds(i - 30),
                  value: visits,
                });
              }
              chart.data = data;

              timeAxis = chart.xAxes.push(new am4charts.ValueAxis());

              var valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
              valueAxis.tooltip.disabled = true;
              valueAxis.renderer.inside = true;
              valueAxis.renderer.axisFills.template.disabled = true;
              valueAxis.renderer.ticks.template.disabled = true;

              series = new Array(BENCHMARK_CONFIG.channelsCount)
                .fill(0)
                .map((_, iChannel) => {
                  var nSeries = chart.series.push(new am4charts.LineSeries());
                  nSeries.dataFields.valueX = 'ax';
                  nSeries.dataFields.valueY = 'ay';
                  return nSeries;
                });

              addNDataPoints(BENCHMARK_CONFIG.timeDomainInterval);

              chart.events.on('ready', () => {
                resolve();
              });
            });
          },
          streamData: () => {
            let tPrev = performance.now();
            let newDataModulus = 0;
            const streamData = () => {
              const tNow = performance.now();
              const tDelta = tNow - tPrev;
              let newDataPointsCount =
                BENCHMARK_CONFIG.channelDataPointsPerSecond * (tDelta / 1000) +
                newDataModulus;
              newDataModulus = newDataPointsCount % 1;
              newDataPointsCount = Math.floor(newDataPointsCount);
              addNDataPoints(newDataPointsCount);
              tPrev = tNow;
              if (!testStopped) {
                requestAnimationFrame(streamData);
              }
            };
            streamData();
          },
        };
      };

      const wait = document.getElementById('wait');
      wait.textContent = 'Fetching data.json ...';
      fetch(BENCHMARK_CONFIG.dataSource)
        .then((result) => result.json())
        .then(async (packedData) => {
          const data = prepareData(packedData);
          sourceData = data;
          wait.textContent = 'Letting chart settle';
          const { renderInitialData, streamData } = createChart(data);
          await new Promise((resolve) =>
            setTimeout(resolve, BENCHMARK_CONFIG.settleTimeMs)
          );

          // Measure initial render speed speed.
          wait.textContent = 'Rendering ...';
          await new Promise((resolve) =>
            requestAnimationFrame(() => requestAnimationFrame(resolve))
          );

          console.time('loadup');
          const heapSizeStart = performance.memory.usedJSHeapSize;
          let tStart = performance.now();
          let loadupSpeedMs = 0;

          await renderInitialData();
          wait.textContent = 'Ready! Streaming data ...';
          console.timeEnd('loadup');
          const heapSizeInitialRender = performance.memory.usedJSHeapSize;
          loadupSpeedMs = performance.now() - tStart;

          // Measure FPS and HEAP SIZE while streaming.
          streamData();
          tStart = performance.now();
          const fpsMeasurements = [];
          const heapSizeMeasurements = [];
          const timeoutMeasurements = [];
          (() => {
            let frames = 0;
            const recordFrame = () => {
              frames++;
              const tNow = performance.now();
              const fps = 1000 / ((tNow - tStart) / frames);
              if (frames >= 5) {
                fpsMeasurements.push(fps);
              }
              if (!testStopped) {
                requestAnimationFrame(recordFrame);
              }
            };
            requestAnimationFrame(recordFrame);
          })();
          (() => {
            let tPrev = tStart;
            const checkHeapSize = () => {
              const tNow = performance.now();
              if (tNow - tPrev > 500) {
                const heapSize = performance.memory.usedJSHeapSize;
                heapSizeMeasurements.push(heapSize);
                tPrev = tNow;
              }
              if (!testStopped) {
                requestAnimationFrame(checkHeapSize);
              }
            };
            checkHeapSize();
          })();
          (() => {
            let tPrev = tStart;
            const check = () => {
              const tNow = performance.now();
              timeoutMeasurements.push(tNow - tPrev);
              tPrev = tNow;
              if (!testStopped) {
                setTimeout(check);
              }
            };
            setTimeout(check);
          })();
          const frameTimeMeasurements = [];
          (() => {
            let frames = 0;
            let tPrev = tStart;
            const check = () => {
              frames++;
              const tNow = performance.now();
              const frameTime = tNow - tPrev;
              if (frames >= 5) {
                frameTimeMeasurements.push(frameTime);
              }
              tPrev = tNow;
              if (!testStopped) {
                requestAnimationFrame(check);
              }
            };
            requestAnimationFrame(check);
          })();

          const checkOver = () => {
            const tNow = performance.now();
            if (tNow - tStart >= BENCHMARK_CONFIG.testDurationSeconds * 1000) {
              // Finish benchmark.
              testStopped = true;
              wait.textContent = 'Benchmark finished. See console for results';

              // Calculate min, max, avg, median from FPS and HEAP SIZE measurements.
              const getNumberArrayStats = (array) => {
                // https://stackoverflow.com/questions/45309447/calculating-median-javascript
                function median(values) {
                  if (values.length === 0) return 0;
                  values.sort((a, b) => a - b);
                  const half = Math.floor(values.length / 2);
                  if (values.length % 2) return values[half];
                  return (values[half - 1] + values[half]) / 2.0;
                }
                return {
                  min: array.reduce(
                    (prev, cur) => Math.min(prev, cur),
                    Number.MAX_SAFE_INTEGER
                  ),
                  max: array.reduce(
                    (prev, cur) => Math.max(prev, cur),
                    -Number.MAX_SAFE_INTEGER
                  ),
                  avg:
                    array.reduce((prev, cur) => prev + cur, 0) / array.length,
                  median: median(array),
                };
              };

              const fpsStats = getNumberArrayStats(fpsMeasurements);
              const heapSizeStats = getNumberArrayStats(heapSizeMeasurements);
              const timeoutStats = getNumberArrayStats(timeoutMeasurements);
              const frameTimeStats = getNumberArrayStats(frameTimeMeasurements);
              const benchmark = {
                config: BENCHMARK_CONFIG,
                timestamp: Date.now(),
                loadupSpeedMs: loadupSpeedMs,
                fps: fpsStats,
                heapSize: {
                  ...heapSizeStats,
                  before: heapSizeStart,
                  afterInitialRender: heapSizeInitialRender,
                },
                timeout: timeoutStats,
                frameTime: frameTimeStats,
              };
              console.log(
                'BENCHMARK RESULTS\n',
                '-----------------\n',
                JSON.stringify(benchmark)
              );
            } else requestAnimationFrame(checkOver);
          };
          requestAnimationFrame(checkOver);
        });
    </script>

    <p id="reference">
      Code based on
      <a href="https://www.amcharts.com/demos/live-data/"
        >https://www.amcharts.com/demos/live-data/</a
      >
    </p>
  </body>
</html>
